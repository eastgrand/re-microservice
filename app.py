from flask import Flask, request, jsonify, abort
from flask_cors import CORS
import pandas as pd
import numpy as np
import logging
import traceback
import os

# Import the master schema and target variable from the data mapping script
from map_nesto_data import MASTER_SCHEMA, TARGET_VARIABLE

# --- Flask App Initialization ---
app = Flask(__name__)
# Enable CORS for all routes, allowing the frontend to fetch the schema
CORS(app)

# --- Logging Configuration ---
logging.basicConfig(level=logging.INFO, format='[%(asctime)s] [%(levelname)s] %(message)s')

# --- Data Loading ---
try:
    # Load the pre-cleaned dataset generated by map_nesto_data.py
    # Get the directory of the current script
    script_dir = os.path.dirname(__file__)
    data_path = os.path.join(script_dir, 'data', 'cleaned_data.csv')
    df = pd.read_csv(data_path)
    AVAILABLE_COLUMNS = set(df.columns)
    logging.info("Successfully loaded cleaned_data.csv.")
    logging.info(f"Available columns for analysis: {', '.join(sorted(list(AVAILABLE_COLUMNS)))}")
except FileNotFoundError:
    logging.error("Fatal: cleaned_data.csv not found. Please run map_nesto_data.py first to generate it.")
    df = None
    AVAILABLE_COLUMNS = set()


# === API Endpoints ===

@app.route('/api/v1/schema', methods=['GET'])
def get_schema():
    """
    Exposes the master data schema to the frontend.
    This is the single source of truth for all field names, aliases, and descriptions.
    """
    if not MASTER_SCHEMA:
        return jsonify({"error": "Schema is not available or failed to load"}), 500

    # Prepare a list of all canonical names for convenience
    known_fields = [details['canonical_name'] for _, details in MASTER_SCHEMA.items()]

    return jsonify({
        "fields": MASTER_SCHEMA,
        "known_fields": known_fields
    })

@app.route('/analyze', methods=['POST'])
def analyze():
    """
    Main analysis endpoint. It validates the request against available data columns
    and returns a mock analysis result.
    """
    if df is None:
        abort(500, description="Dataset not loaded. Cannot perform analysis.")

    # --- Request Validation ---
    if not request.json:
        abort(400, description="Invalid request: Missing JSON body.")

    data = request.json
    target_variable = data.get('target_variable')
    matched_fields = data.get('matched_fields', [])
    
    # Validate that the requested fields are present in our dataset
    all_requested_fields = [target_variable] + matched_fields
    unknown_fields = [field for field in all_requested_fields if field and field not in AVAILABLE_COLUMNS]

    if unknown_fields:
        error_msg = f"Unknown metric fields requested: {', '.join(unknown_fields)}. Please use fields available in the schema."
        abort(400, description=error_msg)

    logging.info(f"Received analysis request with target '{target_variable}' and fields {matched_fields}")

    # --- Mock Analysis ---
    # In a real scenario, this is where the SHAP analysis would run.
    # We will return a structured mock response.
    analysis_results = {
        'success': True,
        'message': 'Analysis complete',
        'target_variable': target_variable,
        'matched_fields': matched_fields,
        'summary': {
            'base_value': 0.5,
            'feature_impacts': {field: np.random.rand() * 0.1 for field in matched_fields}
        },
        'results': [
            {'geo_id': 'A0A', 'shap_values': {field: np.random.rand() for field in matched_fields}, 'prediction': np.random.rand()}
            for i in range(10) # Return top 10 mock results
        ]
    }
    
    # Return the analysis results
    return jsonify(analysis_results)

# === Error Handlers ===

@app.errorhandler(400)
def bad_request(error):
    logging.error(f"Bad Request: {error.description}")
    response = jsonify({'error': 'Bad Request', 'message': error.description})
    response.status_code = 400
    return response

@app.errorhandler(500)
def internal_server_error(error):
    logging.error(f"Internal Server Error: {traceback.format_exc()}")
    response = jsonify({'error': 'Internal Server Error', 'message': 'An unexpected error occurred.'})
    response.status_code = 500
    return response

if __name__ == '__main__':
    # Note: Running in debug mode is not recommended for production
    app.run(debug=True, port=5001)
